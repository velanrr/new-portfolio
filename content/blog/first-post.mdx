---
tag: "Javascript"
link: "blog/first-post"
title: "`any` Considered as harmful, except for these cases"
discription: "Discover when it's appropriate to use Typescript's `any` type..."
date: "2025-07-25"
published: true
thumbnail: "/images/blog/post1.svg"
author: "devbertskie"
---
 
<span className="code">any</span> is an extremely powerful type in TypeScript. It lets you treat a value as if you were in JavaScript, not TypeScript. This means that it disables all of TypeScript's features - type checking, autocomplete, and safety.

```ts
const myFunction = (input: any) => {
  input.someMethod(); 
};

myFunction("abc"); // This will fail at runtime!
```

Using <span className="code">any</span> is rightly considered harmful by most of the community. There are [ESLint rules](https://typescript-eslint.io/rules/no-explicit-any/) to prevent its use. This can turn developers off using <span className="code">any</span> entirely.

However, there are a few advanced cases where <span className="code">any</span> is always the right choice. Here are some of them:

## Type Argument Constraints

Let's imagine we wanted to implement the <span className="code">ReturnType</span> utility in TypeScript. This utility takes a function type and returns the type of its return value.

We need to create a [generic type](https://www.totaltypescript.com/no-such-thing-as-a-generic#generic-types) which takes a function type as a type argument. If we restricted ourselves to not use <span className="code">any</span>, we might use <span className="code">unknown</span>:

```ts
type ReturnType<T extends (...args: unknown[]) => unknown> =
  // Not important for our explanation:
  T extends (...args: unknown[]) => infer R ? R : never;
```

It's not important to understand -all- of this code, only the constraint - <span className="code">T extends (...args: unknown[]) => unknown</span>. What we're saying here is that only functions which accept an arguments array of <span className="code">unknown[]</span> and return <span className="code">unknown</span> are allowed.

It seems to work fine for functions which have no arguments:

```ts
const myFunction = () => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

But it stops working as soon as we add an argument:

```ts
const myFunction = (input: string) => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

In fact, it only works if we change the parameter of our function to <span className="code">input: unknown</span>:

```ts
const myFunction = (input: unknown) => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

So accidentally, we've created a <span className="code">ReturnType</span> function that only works on functions which accept <span className="code">unknown</span> as an argument. This is not what we wanted. We wanted it to work on any function.

The solution is to use <span className="code">any</span> as the type argument constraint:

```ts
type ReturnType<T extends (...args: any[]) => any> = T extends (
  ...args: any[]
) => infer R
  ? R
  : never;

const myFunction = (input: string) => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

Now it works as expected. We're declaring that we don't care what types the function accepts - it could be anything.

The reason this is safe is because we're deliberately declaring a wide type. We're saying "I don't care what the function accepts, as long as it's a function". This is a safe use of <span className="code">any</span>.

## Returning Conditional Types From Generic Functions

In some places, TypeScript's narrowing abilites are not as good as we'd like them to be. Let's say we want to create a function which returns different types based on a condition:

```ts
const youSayGoodbyeISayHello = (input: "hello" | "goodbye") => {
  if (input === "goodbye") {
    return "hello";
  } else {
    return "goodbye";
  }
};

const result = youSayGoodbyeISayHello("hello");
```

This function isn't really doing what we want it to. We want it to return the type <span className="code">"goodbye"</span> when we pass in <span className="code">"hello"</span>. But currently, <span className="code">result</span> is typed as <span className="code">"hello" | "goodbye"</span>.

We can fix this by using a conditional type:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello";
  } else {
    return "goodbye";
  }
};

const goodbye = youSayGoodbyeISayHello("hello");

const hello = youSayGoodbyeISayHello("goodbye");

const hello: "hello";
```

We've added a conditional type to the return type of the function which mirrors our runtime logic. If <span className="code">TInput</span>, inferred from the runtime argument input, is <span className="code">"hello"</span>, we return <span className="code">"goodbye"</span>. Otherwise, we return <span className="code">"hello"</span>.

But there's a problem. I've deliberately disabled the errors in the snippet above. Let's see what happens when we enable them:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello";
  } else {
    return "goodbye";
  }
};
```

Ouch. TypeScript doesn't seem to be matching up the conditional type with the runtime logic. <span className="code">"hello"</span> or <span className="code">"goodbye"</span> can't be returned from the function.

We can fix this by using <span className="code">as</span>, and forcing it to be the correct conditional type:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello" as TInput extends "hello" ? "goodbye" : "hello";
  } else {
    return "goodbye" as TInput extends "hello" ? "goodbye" : "hello";
  }
};
```

We can make this nicer by extracting that logic to a common generic type:

```ts
type YouSayGoodbyeISayHello<TInput extends "hello" | "goodbye"> =
  TInput extends "hello" ? "goodbye" : "hello";

const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): YouSayGoodbyeISayHello<TInput> => {
  if (input === "goodbye") {
    return "hello" as YouSayGoodbyeISayHello<TInput>;
  } else {
    return "goodbye" as YouSayGoodbyeISayHello<TInput>;
  }
};
```

But in these situations, it often makes more sense to use as `<span className="code">any</span>:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello" as any;
  } else {
    return "goodbye" as any;
  }
};
```

Yes, this does make our function less type-safe. We could accidentally return <span className="code">"bonsoir"</span> from the function instead.

But in these situations, it's often better to use <span className="code">as any</span> and add a unit test for this function's behavior. Because of TypeScript's limitations in checking this stuff, this is often as close as you'll get to type safety.

There are several other use cases like this, where inside generic functions you need to use <span className="code">any</span> to get around TypeScript's limitations. To me, this is fine.

## Conclusion

A question remains: should you ban <span className="code">any</span> from your codebase? I think, on balance, the answer should be yes. You should turn on the <span className="code">ESLint rule</span> which prevents its use, and you should avoid it wherever possible.

However, there are cases where <span className="code">any</span> is needed. They're worth using eslint-disable to get around them. So, bookmark this article, and attach it to your PR's when you feel the need to use it.

1. We want everything to look good out of the box.
2. Really just the first reason, that's the whole point of the plugin.
3. Here's a third pretend reason though a list with three items looks more realistic than a list with two items.

## Wrestler Finisher Table

| Wrestler                  | Origin         | Finisher           |
|---------------------------|----------------|--------------------|
| Bret "The Hitman" Hart    | Calgary, AB     | Sharpshooter       |
| Stone Cold Steve Austin   | Austin, TX      | Stone Cold Stunner |
| Randy Savage              | Sarasota, FL    | Elbow Drop         |
| Vader                     | Boulder, CO     | Vader Bomb         |
| Razor Ramon               | Chuluota, FL    | Razor's Edge       |


## Nested List Example

1. **Nested lists are rarely a good idea.**
   - You might feel like you are being really "organized" or something but you are just creating a gross shape on the screen that is hard to read.
   - Nested navigation in UIs is a bad idea too, keep things as flat as possible.
   - Nesting tons of folders in your source code is also not helpful.

2. **Since we need to have more items, here's another one.**
   - I'm not sure if we'll bother styling more than two levels deep.
   - Two is already too much, three is guaranteed to be a bad idea.
   - If you nest four levels deep you belong in prison.

3. **Two items isn't really a list, three is good though.**
   - Again please don't nest lists if you want people to actually read your content.
   - Nobody wants to look at this.
   - I'm upset that we even have to bother styling this.


## üñºÔ∏è Post Image
<img
  src="/images/blog/post2.webp"
  alt="Blog Thumbnail"
  width="640"
  height="360"
  className="rounded-lg shadow-lg"
/>


---
> This is a simple blockquote.
> ‚ÄúPrograms must be written for people to read, and only incidentally for machines to execute.‚Äù
> ‚Äî Harold Abelson

